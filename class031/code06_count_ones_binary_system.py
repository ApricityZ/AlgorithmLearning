# // 返回n的二进制中有几个1
# // 两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。
# // 给你两个整数 x 和 y，计算并返回它们之间的汉明距离
# // 测试链接 : https://leetcode.cn/problems/hamming-distance/

class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        return self.count(x ^ y)

    def count(self, n):
        n = (n & 0x55555555) + ((n >> 1) & 0x55555555)
        n = (n & 0x33333333) + ((n >> 2) & 0x33333333)
        n = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f)
        n = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff)
        n = (n & 0x0000ffff) + ((n >> 16) & 0x0000ffff)
        return n

    def wrong_count1(self, n):
        n = (n & 0xaaaaaaaa) + ((n << 1) & 0xaaaaaaaa)
        n = (n & 0xcccccccc) + ((n << 2) & 0xcccccccc)
        n = (n & 0xf0f0f0f0) + ((n << 4) & 0xf0f0f0f0)
        n = (n & 0xff00ff00) + ((n << 8) & 0xff00ff00)
        n = (n & 0xffff0000) + ((n << 16) & 0xffff0000)
        return n
    # 您的写法 (使用 << 左移)：通过向左移位，您实际上是将位的权重提高了。每次操作后，信息（或者说计算的中间值）都被推向了二进制数的高位。最终的结果是一个包含了各种位信息混合在一起的大数，而不是一个简单的计数。
    #
    # 标准的计数算法 (使用 >> 右移)：这个算法的精髓在于合并与累加。通过向右移位，它将高位的 bit 信息移动到低位，与原本就在低位的信息进行相加。
    #
    # 第一步 (n & 0x55...) + ((n >> 1) & 0x55...)，就是把每2位中的高位（第1位）右移下来和低位（第0位）对齐相加，结果存放在这个2位的空间里。
    #
    # 第二步 (n & 0x33...) + ((n >> 2) & 0x33...)，就是把每4位中的高2位（代表一个计数值）右移下来和低2位（代表另一个计数值）对齐相加，结果存放在这个4位的空间里。
    #
    # ...以此类推。
    #
    # 这个过程就像一个锦标赛的晋级图，不断将相邻的结果两两合并，最终将总和（冠军）汇集到了数字的最右边，也就是低位。
