def calculate_total(price, quantity):
    # 步骤 2: 'calculate_total' 函数被调用
    #         - 一个新的栈帧被创建并压入栈顶。
    #         - 名字 price 和 quantity 在这个栈帧中创建。
    #         - 它们的值（引用）分别指向堆中数字对象 10.5 和 3。

    cost = price * quantity
    # 步骤 3: 乘法运算
    #         - 在堆中创建一个新的数字对象 31.5。
    #         - 在当前栈帧中创建一个名字 cost，让它引用这个新的 31.5 对象。

    return cost
    # 步骤 4: 函数返回
    #         - 将 cost 的引用（指向 31.5 的地址）作为返回值。
    #         - 'calculate_total' 的栈帧被销毁（出栈）。
    #           名字 price, quantity, cost 随之消失。

# ================= 主程序开始 =================
# 步骤 1: 全局作用域（可以看作是栈的底部）
#         - 在堆中创建了一个数字对象 10.5，名字 'item_price' 引用它。
#         - 在堆中创建了一个数字对象 3，名字 'item_count' 引用它。
item_price = 10.5
item_count = 3

total_cost = calculate_total(item_price, item_count)
# 步骤 5: 赋值操作
#         - 函数返回的引用（指向 31.5 的地址）被赋给全局名字 'total_cost'。
#         - 现在 'total_cost' 这个名字指向了堆中的 31.5 对象。

print(total_cost)
# 步骤 6: 程序结束
#         - 堆中的对象 10.5, 3, 31.5 因为不再被任何名字引用（假设程序就此结束），
#           最终会被垃圾回收器清理。

#######
#关键总结
# 栈是关于“谁调用了谁”和“临时变量在哪”。它管理着程序的执行流，像一个严格的短期记事本。
#
# 堆是关于“数据实际是什么和在哪里”。它是所有数据的家，由Python的内存管理器精心照料。
#
# Python中，变量（名字）存放在栈上，而变量所引用的数据（对象）存放在堆上。 栈上的变量只是一个指向堆中对象的“路牌”。
#
# 正是因为所有对象都在堆上，所以Python可以方便地实现动态类型和灵活的数据结构。你把一个列表传来传去，其实只是在复制它在堆上的地址，而不是整个列表，这非常高效。