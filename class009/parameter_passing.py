# ===============================================================
# 1. 验证不可变类型 (Immutable Types)
# 对应 Java 的: int, long, byte, short, char, float, double, boolean, String
# Python 中对应的例子: int, float, bool, str, tuple
# ===============================================================

def f(a):
    """
    函数内部对 a 重新赋值。
    因为整数是不可变类型，这会在函数内部创建一个新的整数对象，并让局部变量 a 指向它。
    这完全不影响函数外部的 a。
    """
    print(f"  进入函数 f, a 的内存地址: {id(a)}, a 的值: {a}")
    a = 0
    print(f"  函数 f 内重新赋值后, 函数内部局部变量a 的内存地址: {id(a)}, a 的值: {a}")


print("--- 验证不可变类型 (int) ---")
a = 10
print(f"调用前, a 的内存地址: {id(a)}, a 的值: {a}")
f(a)
print(f"调用后, a 的值: {a}")  # 输出结果: 10
print("\n" + "=" * 30 + "\n")


# ===============================================================
# 2. 验证可变类型 (Mutable Types)
# 对应 Java 的: 自定义类对象, 数组
# Python 中对应的例子: class instance, list, dict, set
# ===============================================================

class Number:
    """对应 Java 的 Number 类"""

    def __init__(self, v):
        self.val = v


def g1(b):
    """
    函数内部将 b 重新赋值为 None。
    这只是让函数内的局部变量 b 不再指向原来的 Number 对象，
    而是指向了 None。函数外的原始变量不受影响。
    对应 Java 的 g1(b) -> b = null;
    """
    print(f"  进入函数 g1, b 指向的内存地址: {id(b)}, b.val: {b.val if b else 'None'}")
    b = None
    print(f"  函数 g1 内重新赋值后, 函数内部局部变量b 指向的内存地址: {id(b)}, b 的值: {b}")


def g2(b):
    """
    函数通过引用修改了对象内部的属性。
    因为内外两个变量都指向同一个 Number 对象，所以修改会生效。
    对应 Java 的 g2(b) -> b.val = 6;
    """
    print(f"  进入函数 g2, b 指向的内存地址: {id(b)}, b.val: {b.val}")
    b.val = 6
    print(f"函数 g2 内修改属性后, 函数内部局部变量b 指向的内存地址: {id(b)}, b.val: {b.val}")


def g3(c):
    """
    函数内部将 c 重新赋值为 None。
    这只会改变函数内的局部变量 c，使其不再指向原来的列表。
    对应 Java 的 g3(c) -> c = null;
    """
    print(f"  进入函数 g3, c 指向的内存地址: {id(c)}, c 的值: {c}")
    c = None
    print(f"  函数 g3 内重新赋值后, 函数内部局部变量 c 指向的内存地址: {id(c)}， c 的值: {c}")


def g4(c):
    """
    函数通过引用修改了列表内部的元素。
    因为内外两个变量都指向同一个 list 对象，所以修改会生效。
    对应 Java 的 g4(c) -> c[0] = 100;
    """
    print(f"  进入函数 g4, c 指向的内存地址: {id(c)}, c 的值: {c}")
    c[0] = 100
    print(f"  函数 g4 内修改元素后, 函数内部局部变量 c 指向的内存地址: {id(c)}， c 的值: {c}")


# --- 验证自定义类对象 ---
print("--- 验证可变类型 (自定义类) ---")
b = Number(5)
print(f"调用 g1 前, b 指向的内存地址: {id(b)}, b.val: {b.val}")
g1(b)
# 输出结果: 5 (因为 g1 只是把函数内的局部引用置空了)
print(f"调用 g1 后, b 指向的内存地址: {id(b)}, b.val 的值: {b.val}")

print("-" * 20)

print(f"调用 g2 前, b 指向的内存地址: {id(b)}, b.val: {b.val}")
g2(b)
# 输出结果: 6 (因为 g2 通过引用修改了对象内部的值)
print(f"调用 g2 后, b 指向的内存地址: {id(b)}, b.val 的值: {b.val}")
print("\n" + "=" * 30 + "\n")

# --- 验证列表 (对应 Java 的数组) ---
print("--- 验证可变类型 (列表) ---")
c = [1, 2, 3, 4]
print(f"调用 g3 前, c 指向的内存地址: {id(c)}, c 的值: {c}")
g3(c)
# 输出结果: 1 (因为 g3 只是把函数内的局部引用置空了)
print(f"调用 g3 后, c[0] 的值: {c[0]}")
print(f"调用 g3 后, c 指向的内存地址: {id(c)}, 整个 c 列表: {c}")

print("-" * 20)

print(f"调用 g4 前, c 指向的内存地址: {id(c)}, c 的值: {c}")
g4(c)
# 输出结果: 100 (因为 g4 通过引用修改了列表内部的元素)
print(f"调用 g4 后, c[0] 的值: {c[0]}")
print(f"调用 g4 后, c 指向的内存地址: {id(c)}, 整个 c 列表: {c}")

# python总数按值传递的，即使看起来像是按引用传递的，但是其实传递的只是引用的复制，所以永远无法在函数内部修改被调用的参数指向的内存，
# 比如上面永远修改不了实参 b 或者 c 指向的内存地址，只能修改指向内存对象的值。
